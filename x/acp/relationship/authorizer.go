package relationship

import (
    "context"

    "github.com/sourcenetwork/sourcehub/x/acp/types"
    "github.com/sourcenetwork/sourcehub/x/acp/auth_engine"
)

const ManagementPermissionPrefix string = "_can_manage_"

func NewRelationshipAuthorizer(engine auth_engine.AuthEngine) RelationshipAuthorizer {
    return RelationshipAuthorizer{
        engine: engine,
    }
}

// RelationshipAuthorizer acts as an Authorization Request engine 
// which validates whether a Relationship can be created by an Actor.
//
// A given Relationship is only valid if for the Relationship's Object and Relation
// the Actor has an associated permission to manage the Object, Relation pair.
//
// The Permission evaluation is done through a Check call using the auxiliary permissions
// auto generated by the ACP module and attached to a permission.
//
// For instance, take the Relationship (obj:foo, reader, steve) being submitted by Actor Bob.
// Bob is allowed to Create that relationship if and only if:
// Bob has the permission _can_manage_reader for "obj:foo".
type RelationshipAuthorizer struct {
    engine auth_engine.AuthEngine
}

func (a *RelationshipAuthorizer) IsAuthorized(ctx context.Context, policy *types.Policy, relationship *types.Relationship, creator *types.Actor) (bool, error) {
    authRequest := &types.AuthorizationRequest{
        Object: relationship.Object,
        Relation: policy.GetManagementPermissionName(relationship.Relation),
    }

    return a.engine.Check(ctx, policy, authRequest, creator)
}
